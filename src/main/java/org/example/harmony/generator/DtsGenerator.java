package org.example.harmony.generator;

import org.example.harmony.model.DependencyInfo;
import org.example.harmony.model.ImportInfo;
import org.example.harmony.model.TypeInfo;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.util.*;
import java.util.stream.Collectors;

/**
 * DTS文件生成器
 * 为外部依赖生成TypeScript声明文件(index.d.ts)
 */
public class DtsGenerator {
    private static final Logger logger = LoggerFactory.getLogger(DtsGenerator.class);

    /**
     * 已知库的API模板
     * key: 模块路径
     * value: 预定义的DTS内容模板
     */
    private static final Map<String, String> KNOWN_LIBRARY_TEMPLATES = Map.of(
            "@pura/harmony-utils",
            """
                    export type Permissions = string;

                    export declare class PermissionUtil {
                        static checkPermissions(permission: Permissions | Permissions[]): Promise<boolean>;

                        static checkRequestPermissions(permission: Permissions | Permissions[]): Promise<boolean>;

                        static requestPermissions(permissions: Permissions | Permissions[]): Promise<boolean>;

                        static requestPermissionsEasy(permissions: Permissions | Permissions[]): Promise<boolean>;

                        static requestPermissionOnSetting(permissions: Permissions | Permissions[]): Promise<boolean>;

                        static requestPermissionOnSettingEasy(permissions: Permissions[]): Promise<boolean>;

                        static requestGlobalSwitch(type: number): Promise<boolean>;
                    }
                    """,
            "@kit.AbilityKit",
            """
                    export type Permissions = string;

                    export declare namespace abilityAccessCtrl {
                        type SwitchType = number;
                        const SWITCH_TYPE_MICROPHONE: 1;
                        const SWITCH_TYPE_CAMERA: 2;
                        const SWITCH_TYPE_LOCATION: 3;
                    }
                    """
    );

    /**
     * 为单个依赖生成DTS文件
     *
     * @param dependency 依赖信息
     * @param outputPath 输出目录（依赖的根目录）
     */
    public void generate(DependencyInfo dependency, String outputPath) throws IOException {
        Path dtsPath = Paths.get(outputPath, "index.d.ts");

        logger.info("Generating DTS file: {}", dtsPath);
        logger.debug("  Module: {}", dependency.getModulePath());
        logger.debug("  Types: {}", dependency.getReferencedTypes().size());

        StringBuilder content = new StringBuilder();

        // 添加文件头注释
        content.append("// Auto-generated by ets-har-builder\n");
        content.append("// Module: ").append(dependency.getModulePath()).append("\n");
        content.append("// DO NOT EDIT - This file was generated automatically\n\n");

        // 检查是否有预定义的模板
        if (KNOWN_LIBRARY_TEMPLATES.containsKey(dependency.getModulePath())) {
            content.append(KNOWN_LIBRARY_TEMPLATES.get(dependency.getModulePath()));
            content.append("\n");
        } else {
            // 按类型分组
            Map<String, List<TypeInfo>> typesByKind = dependency.getReferencedTypes().stream()
                    .collect(Collectors.groupingBy(TypeInfo::getKind));

        // 生成命名空间（如果有）
        if (typesByKind.containsKey("namespace")) {
            for (TypeInfo ns : typesByKind.get("namespace")) {
                content.append(generateNamespaceDeclaration(ns, dependency))
                        .append("\n");
            }
        }

            // 生成类型别名
            if (typesByKind.containsKey("type")) {
                for (TypeInfo type : typesByKind.get("type")) {
                    content.append(generateTypeDeclaration(type))
                            .append("\n");
                }
            }

            // 生成接口
            if (typesByKind.containsKey("interface")) {
                for (TypeInfo iface : typesByKind.get("interface")) {
                    content.append(generateInterfaceDeclaration(iface))
                            .append("\n");
                }
            }

            // 生成类
            if (typesByKind.containsKey("class")) {
                for (TypeInfo cls : typesByKind.get("class")) {
                    content.append(generateClassDeclaration(cls, dependency))
                            .append("\n");
                }
            }

            // 生成枚举
            if (typesByKind.containsKey("enum")) {
                for (TypeInfo enumType : typesByKind.get("enum")) {
                    content.append(generateEnumDeclaration(enumType))
                            .append("\n");
                }
            }

            // 生成函数
            if (typesByKind.containsKey("function")) {
                for (TypeInfo func : typesByKind.get("function")) {
                    content.append(generateFunctionDeclaration(func, dependency))
                            .append("\n");
                }
            }

            // 生成常量
            if (typesByKind.containsKey("const")) {
                for (TypeInfo constant : typesByKind.get("const")) {
                    content.append(generateConstDeclaration(constant))
                            .append("\n");
                }
            }

            // 添加额外声明
            for (Map.Entry<String, String> entry : dependency.getExtraDeclarations().entrySet()) {
                content.append("// Extra declaration for: ").append(entry.getKey()).append("\n");
                content.append(entry.getValue()).append("\n\n");
            }
        }  // end of else block

        // 确保输出目录存在
        Files.createDirectories(Paths.get(outputPath));

        // 写入文件
        Files.writeString(dtsPath, content.toString(), StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);

        logger.info("Generated DTS file with {} declarations", content.toString().split("\n").length);
    }

    /**
     * 生成命名空间声明
     */
    private String generateNamespaceDeclaration(TypeInfo ns, DependencyInfo dependency) {
        StringBuilder sb = new StringBuilder();
        sb.append("declare namespace ").append(ns.getName()).append(" {\n");

        // 查找该命名空间下的子类型
        List<TypeInfo> children = dependency.getReferencedTypes().stream()
                .filter(t -> !t.getKind().equals("namespace"))
                .collect(Collectors.toList());

        if (!children.isEmpty()) {
            sb.append("  // Nested types\n");
            for (TypeInfo child : children) {
                sb.append("  ").append(generateInlineDeclaration(child)).append("\n");
            }
        }

        sb.append("}\n");
        return sb.toString();
    }

    /**
     * 生成类型别名声明
     */
    private String generateTypeDeclaration(TypeInfo type) {
        // 尝试生成更精确的类型声明
        if (type.getName().equals("Permissions")) {
            return "export type Permissions = string;\n";
        }
        return type.getSignature() + "\n";
    }

    /**
     * 生成接口声明
     */
    private String generateInterfaceDeclaration(TypeInfo iface) {
        StringBuilder sb = new StringBuilder();
        sb.append("export interface ").append(iface.getName()).append(" {\n");

        // 添加常用属性（如果已知）
        if (iface.getName().contains("Result")) {
            sb.append("  success: boolean;\n");
            sb.append("  code?: number;\n");
            sb.append("  message?: string;\n");
        }

        sb.append("}\n");
        return sb.toString();
    }

    /**
     * 生成类声明
     */
    private String generateClassDeclaration(TypeInfo cls, DependencyInfo dependency) {
        StringBuilder sb = new StringBuilder();

        // 根据类名生成更精确的声明
        String className = cls.getName();

        sb.append("export class ").append(className);

        // 添加泛型参数（如果有）
        if (cls.getTypeParameters() != null) {
            sb.append(cls.getTypeParameters());
        }

        sb.append(" {\n");
        sb.append("  constructor(...args: any[]);\n");

        // 根据类名推断常用方法
        if (className.endsWith("Manager") || className.endsWith("Controller")) {
            sb.append("  static getInstance(): ").append(className).append(";\n");
        }

        // 添加异步方法（如果引用了await）
        for (ImportInfo importInfo : dependency.getImportInfos()) {
            if (importInfo.getImportedName().equals(className)) {
                // 检查源代码中是否有await调用
                sb.append("  // Methods inferred from usage\n");
                sb.append("  [key: string]: any;\n");
                break;
            }
        }

        sb.append("}\n");
        return sb.toString();
    }

    /**
     * 生成枚举声明
     */
    private String generateEnumDeclaration(TypeInfo enumType) {
        StringBuilder sb = new StringBuilder();
        sb.append("export enum ").append(enumType.getName()).append(" {\n");

        // 添加常见的枚举值（如果已知）
        if (enumType.getName().equals("SwitchType")) {
            sb.append("  MICROPHONE = 1,\n");
            sb.append("  CAMERA = 2,\n");
            sb.append("  LOCATION = 3,\n");
        }

        sb.append("}\n");
        return sb.toString();
    }

    /**
     * 生成函数声明
     */
    private String generateFunctionDeclaration(TypeInfo func, DependencyInfo dependency) {
        StringBuilder sb = new StringBuilder();
        String funcName = func.getName();

        sb.append("export declare function ").append(funcName).append("(");

        // 根据函数名推断参数
        List<String> params = inferParameters(funcName);
        sb.append(String.join(", ", params));

        sb.append("): ").append(inferReturnType(funcName)).append(";\n");

        return sb.toString();
    }

    /**
     * 生成常量声明
     */
    private String generateConstDeclaration(TypeInfo constant) {
        return "export declare const " + constant.getName() + ": any;\n";
    }

    /**
     * 生成内联声明（用于命名空间内部）
     */
    private String generateInlineDeclaration(TypeInfo type) {
        switch (type.getKind()) {
            case "type":
                return "type " + type.getName() + " = any;";
            case "interface":
                return "interface " + type.getName() + " {}";
            case "class":
                return "class " + type.getName() + " {}";
            case "function":
                return "function " + type.getName() + "(...args: any[]): any;";
            case "const":
                return "const " + type.getName() + ": any;";
            case "enum":
                return "enum " + type.getName() + " {}";
            default:
                return "var " + type.getName() + ": any;";
        }
    }

    /**
     * 根据函数名推断参数
     */
    private List<String> inferParameters(String funcName) {
        List<String> params = new ArrayList<>();

        if (funcName.contains("check")) {
            params.add("permission: string | string[]");
        } else if (funcName.contains("request")) {
            params.add("permissions: string | string[]");
        } else if (funcName.contains("Permission")) {
            params.add("permission: string | string[]");
        } else {
            params.add("...args: any[]");
        }

        return params;
    }

    /**
     * 根据函数名推断返回类型
     */
    private String inferReturnType(String funcName) {
        if (funcName.contains("check")) {
            return "Promise<boolean>";
        } else if (funcName.contains("request")) {
            return "Promise<boolean>";
        } else if (funcName.startsWith("is") || funcName.startsWith("has")) {
            return "boolean";
        } else if (funcName.startsWith("get")) {
            return "Promise<any>";
        }
        return "any";
    }

    /**
     * 为依赖生成oh-package.json5文件
     */
    public void generateOhPackageJson(DependencyInfo dependency, String outputPath) throws IOException {
        Path jsonPath = Paths.get(outputPath, "oh-package.json5");

        StringBuilder content = new StringBuilder();
        content.append("{\n");
        content.append("  \"name\": \"").append(dependency.getOhPackageName()).append("\",\n");
        content.append("  \"version\": \"1.0.0\",\n");
        content.append("  \"description\": \"Auto-generated stub for ").append(dependency.getModulePath()).append("\",\n");
        content.append("  \"main\": \"index.d.ts\",\n");
        content.append("  \"author\": \"ets-har-builder\",\n");
        content.append("  \"license\": \"MIT\",\n");
        content.append("  \"dependencies\": {}\n");
        content.append("}\n");

        Files.writeString(jsonPath, content.toString(), StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);

        logger.info("Generated oh-package.json5: {}", jsonPath);
    }
}
